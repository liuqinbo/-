一 路由
 
  1.路由的配置
    import Page1 from '../container/Page1';
    import Page2 from '../container/Page2';
    import React from 'react';
    import {Router,Route,Switch,Redirect} from 'react-router-dom';
    //import { createHashHistory } from "history";
    //const history = createHashHistory();
    class RouterConfig extends React.Component{
        render(){
	    return(
	         //<Router history={history}>
		 <Router>
		    <Switch>
		        //路由重定向,exact表示严格匹配
		        <Route path='/' exact render={()=>(
			    <Redirect to='/Page1'/>
		        )}/> 
		        <Route path='/Page1' component={Page1}/>
		        <Route path='/Page2' component={Page2}/>
			<Route path="inbox" component={Inbox}> //嵌套路由
			    <Route path="/messages/:id" component={Message} />
			    {/* 动态路由 跳转 /inbox/messages/:id 到 /messages/:id */}
			    <Redirect from="messages/:id" to="/messages/:id" />
     			</Route>
		    </Switch>
	        </Router>
	    )
        }
    }
    export default RouterConfig;
    //入口文件 index.js
    import RouterConfig from './router';
    ReactDOM.render(<RouterConfig/>, document.getElementById('root'));
    
  2.路由的跳转与传参
    (1)引入式跳转与传参 
    import { Link } from 'react-router-dom' 
    <Link to='/路由' >home</Link> //跳转 
    <Link to={ {pathname:`/路由`} }>home</Link> //跳转 
    <Link to='/路由/参数字符串'>home</Link> //params跳转传参(动态路由传参) this.props.match.params接收参数,刷新参数不消失,参数在地址栏显示
    <Link to={ {pathname:`/路由`,query:{key值：val值}} } >home</Link> //query跳转传参 this.props.location.query接收参数,刷新参数消失,参数在地址栏不显示
    <Link to={ {pathname:`/路由`,state:{key值：val值}} } >home</Link> //state跳转传参 this.props.location.state接收参数,刷新参数不消失,参数在地址栏不显示
    (2)编程式跳转与传参
    this.props.history.push('/路由')//跳转
    this.props.history.push({pathname:`/路由`})//跳转
    this.props.history.push('/路由/参数字符串') //params跳转传参(动态路由传参)  this.props.match.params接收参数,刷新参数不消失,参数在地址栏显示
    this.props.history.push({pathname:`/路由`,query:{key值：val值}})//query跳转传参 this.props.location.query接收参数,刷新参数消失,参数在地址栏不显示
    this.props.history.push({pathname:`/路由`,state:{key值：val值}})//state跳转传参 this.props.location.state接收参数,刷新参数不消失,参数在地址栏不显示
    
  3.进阶--> 路由守卫
    可以用render来实现
    
二 页面间的数据传递

  组件名：对于react来说类名就是组件名
  1.父子页面之前的传递
    案例网址：https://blog.csdn.net/qq_46370075/article/details/107229824
    (1)父传子
    父：<子组件名称  属性名称 = {传递的数据} /> 
    子：this.props.属性名称 
    (2)子传父
     父：定义函数、<子组件名称  属性名称 = {函数(参数)} /> 
     子：this.props.属性名称(参数)
     
  2.兄弟页面之间的传递
    (1)通过先传给父，再由父传给其他子组件
    
  3.深层次的传递
    redux则是一个纯粹的状态管理系统，任何的框架都可以用
    react-redux是针对react将redux和react框架结合起来使用的东西
    (1)redux创建一个store
       一般用法
       import { createStore } from 'redux'
       let defaultState = { goodlist: [] }
       function reducer(state = defaultState, action) {
           switch (action.type) {
                case 'ADD_TO_CART':
                   return {
                        ...state,
                        goodlist: [...state.goodlist, action.payload]
                   }
               default:
                   return state
            }
       }
       const store = createStore(reducer)
       export default store;
       
       模块化
       import {combineReducers} from 'redux';
       import cartReducer from './cart';
       import commonReducer from './common';

       export default combineReducers({
           cart:cartReducer,
           common:commonReducer
       });
  	    模块cart，common一般用法一样写。
	      原本state.属性变成 state.cart/common(模块名).属性
    (2)用react-redux将store与Provide 联合起来
      import { Provider } from 'react-redux';
      import store from './redux'
      <Provider store={store}>
          <HashRouter>
             <App />
          </HashRouter>
       </Provider>
    (3)使用方法
       作用：connect是连接React组件与 Redux store
       import { connect } from 'react-redux'
       //下面的return后会在props中
       const mapStateToProps = (state) => {
         return {
           goodlist: state.goodlist 
         }
         
       }
       const mapDispatchToProps = (dispatch) => {
          return {
               change(value) {
                   let action = {
                       type: 'ADD_TO_CART',
                       payload: value
                   }
                   //change方法会通过dispatch触发reducer.js里的修改方法
                   dispatch(action)
               }
          }
        }
        //mapStateToProps，把state映射到组件props中。mapDispatchToProps把dispatch映射到组件props中
        export default connect(mapStateToProps,mapDispatchToProps)(组件名)
     (4)新方法：Dva
     
三 网络请求
  
  1.用XMLHttpRequest创建的请求或者jq的ajax请求
    实例地址：https://zhuanlan.zhihu.com/p/191391288
  2.axios
  创建实例
  import axios from 'axios' 
  import React from 'react';
  const instance = axios.create({
  	method:'post/get',//默认请求方式
	baseURL:'http://127.0.0.1',//默认请求路径
	headers:{'key':1},//默认请求头
	timeout:5000,/默认请求超时时间
  })
  //将instance实例和axios放入全局这样在哪个页面都可以使用了
  React.Component.prototype.$axios = axios
  React.Component.prototype.$instance = instance
  页面中的使用
  import React, { Component } from 'react'
  async example(){
      try{
            let data = await this.instance({
                url:'/index',
                data:{
                      key:1
                }
            })
           //得到data后面就可以写你要的逻辑了
	   if(data.code==0){
	       xxx
	   }
      }catch(err){
	  console.log(err)
      }
  }
  因为之前创建实例的时候都定义了默认的东西，所以在用的时候如果没有修改的话直接这样写就行。
  因为是异步请求所以会用到async 和 await
  
四 事件(交互功能)

  1.事件的添加与定义
  2.事件的传参
  
五 属性等基本使用的总结
  1.数据的绑定
  2.变量在html中的使用方式
  3.变量的定义、赋值与改变
  4.生命周期
