具体用法
1.mian.js
实例引入从 import Vue from 'vue' => import { createApp } from 'vue ;  const app = createApp(App)
全局变量从 Vue.prototype.名字 => app.config.globalProperties.名字 如果用 createApp(App).config.globalProperties.名字 会定义失败(暂时未去深究原因)
插件使用从 Vue.use(插件名) => app.use(插件名)
全局组件从 Vue.component('组件名',组件变量) => app.component('组件名',组件变量)
挂载app的方式从 new Vue({router,render: h => h(App)}).$mount('#app')    =>   app.use(router).mount('#app')

2.路由router
实例引入从 
import Vue from 'vue'、import VueRouter from 'vue-router'     =>  import { createRouter, createWebHashHistory(hash模式)或createWebHistory(history模式)} from 'vue-router'
Vue.use(VueRouter)                                            =>  删除不用了
let router = new VueRouter({base:'/', mode: 'hash',  routes:[省略]}）  =>  const router = createRouter({history : createWebHashHistory(第一个参数为base)或createWebHistory(第一个参数为base),routes:[省略-没变] })
重定向从(未完善好) {path:'*',redirect:{path:'/home'}}  => 捕获所有路由 ( * ) 时，现在必须使用带有自定义正则表达式的参数进行定义 {path:/:pathMatch(.*),redirect:{path:'/home'}}
导出、引入vue文件页面没变(export default router、import 名字 from 页面位置 )

3.vuex 
import Vue from 'vue'、import Vuex from 'vuex'             =>   import { createStore } from 'vuex'
Vue.use(Vuex)                                              =>   删除不用了
let store = new Vuex.Store({省略})                         =>   const store = createStore({省略-没变})
export default store 没变化
1、2、3都是构造实例的方式发生了改变，使用方法没有变化

4.生命周期钩子函数
beforeCreate  =>  setup() (已删除如果需要的话内部的方法写在此里面)
created       =>  setup() (已删除如果需要的话内部的方法写在此里面)
beforeMount   =>  onBeforeMount
mounted       =>  onMouted
beforeUpdate  =>  onBeforeUpdate
updated       =>  onUpdated
beforeDestroy =>  onBeforeUnmount
destroyed     =>  onUnmouted
这些新的生命周期钩子函数只能在 setup() 里使用

5.setup

1) setup里this的指向问题
需要注意的是setup里的this不是指向vue实例而是undefined应为是在解析前调用的setup，所以出现了一个来代替指向vue实例的变量ctx。
import { getCurrentInstance  } from "vue"  const {ctx} = getCurrentInstance() 这里的ctx才是跟以前的this一样指向vue实例

2) setup的参数 
参数1:props  
setup(props){} 注意props对象是响应式的，watch或watchEffect会观察和响应props的更新，但是注意不能解构props对象那样会失去响应性
setup({name}){} name失去响应性。在开发过程中，props 对象对用户空间代码是不可变的（用户代码尝试修改 props 时会触发警告）

参数2:context 
setup(props,context){ 
    context.attrs
    context.slots
    context.emit
} context参数提供了一个上下文对象，从原来 2.x 中 this 选择性地暴露了一些 property。
attrs 和 slots 都是内部组件实例上对应项的代理，可以确保在更新后仍然是最新值。所以可以解构，无需担心后面访问到过期的值

6.响应式系统API
1)reactive
2)ref
3)computed
4)readonly
5)watchEffect
6)watch



