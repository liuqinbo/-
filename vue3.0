具体用法
1.mian.js
实例引入从 import Vue from 'vue' => import { createApp } from 'vue ;  const app = createApp(App)
全局变量从 Vue.prototype.名字 => app.config.globalProperties.名字 如果用 createApp(App).config.globalProperties.名字 会定义失败(暂时未去深究原因)
插件使用从 Vue.use(插件名) => app.use(插件名)
全局组件从 Vue.component('组件名',组件变量) => app.component('组件名',组件变量)
挂载app的方式从 new Vue({router,render: h => h(App)}).$mount('#app')    =>   app.use(router).mount('#app')

2.路由router
实例引入从 
import Vue from 'vue'、import VueRouter from 'vue-router'     =>  import { createRouter, createWebHashHistory(hash模式)或createWebHistory(history模式)} from 'vue-router'
Vue.use(VueRouter)                                            =>  删除不用了
let router = new VueRouter({base:'/', mode: 'hash',  routes:[省略]}）  =>  const router = createRouter({history : createWebHashHistory(第一个参数为base)或createWebHistory(第一个参数为base),routes:[省略-没变] })
重定向从(未完善好) {path:'*',redirect:{path:'/home'}}  => 捕获所有路由 ( * ) 时，现在必须使用带有自定义正则表达式的参数进行定义 {path:/:pathMatch(.*),redirect:{path:'/home'}}
导出、引入vue文件页面没变(export default router、import 名字 from 页面位置 )

3.vuex 
import Vue from 'vue'、import Vuex from 'vuex'             =>   import { createStore } from 'vuex'
Vue.use(Vuex)                                              =>   删除不用了
let store = new Vuex.Store({省略})                         =>   const store = createStore({省略-没变})
export default store 没变化
1、2、3都是构造实例的方式发生了改变，使用方法没有变化

4.生命周期钩子函数
beforeCreate  =>  setup() (已删除如果需要的话内部的方法写在此里面)
created       =>  setup() (已删除如果需要的话内部的方法写在此里面)
beforeMount   =>  onBeforeMount
mounted       =>  onMouted
beforeUpdate  =>  onBeforeUpdate
updated       =>  onUpdated
beforeDestroy =>  onBeforeUnmount
destroyed     =>  onUnmouted
除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：
onRenderTracked
onRenderTriggered
两个钩子函数都接收一个 DebuggerEvent，与 watchEffect 参数选项中的 onTrack 和 onTrigger
  onRenderTriggered(e) {
    debugger
    // 检查哪个依赖性导致组件重新渲染
  },
这些新的生命周期钩子函数只能在 setup() 里使用

5.setup
1) setup里this的指向问题
需要注意的是setup里的this不是指向vue实例而是undefined应为是在解析前调用的setup，所以出现了一个来代替指向vue实例的变量ctx。
import { getCurrentInstance  } from "vue"  const {ctx} = getCurrentInstance() 这里的ctx才是跟以前的this一样指向vue实例

2) setup的参数 
参数1:props  
setup(props){} 注意props对象是响应式的，watch或watchEffect会观察和响应props的更新，但是注意不能解构props对象那样会失去响应性
setup({name}){} name失去响应性。在开发过程中，props 对象对用户空间代码是不可变的（用户代码尝试修改 props 时会触发警告）

参数2:context 
setup(props,context){ 
    context.attrs
    context.slots
    context.emit
} context参数提供了一个上下文对象，从原来 2.x 中 this 选择性地暴露了一些 property。
attrs 和 slots 都是内部组件实例上对应项的代理，可以确保在更新后仍然是最新值。所以可以解构，无需担心后面访问到过期的值

6.响应式系统API
1)reactive
接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 Vue.observable()
响应式转换是“深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。

2)ref
接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性'.value'，如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。
当 ref 作为渲染上下文的属性返回（即在setup() 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 .value：

3)computed
传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。
传入一个拥有 get 和 set 函数的对象，创建一个可手动修改的计算状态。

4)readonly
传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的。

5)watchEffect
立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。
当 watchEffect 在组件的 setup() 函数或生命周期钩子被调用时， 侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。
有时副作用函数会执行一些异步的副作用, 这些响应需要在其失效时清除（即完成之前状态已改变了）。所以侦听副作用传入的函数可以接收一个 onInvalidate 函数作入参, 用来注册清理失效时的回调

6)watch
与2.0的一样


